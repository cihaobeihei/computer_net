# 数据库锁

## 1.问题
- 1.MySIAM与InnoDB关于锁方面的区别是什么?
- 2.数据库事务的四大特性是什么?
- 3.事务的隔离级别以及各级别下的并发访问问题?
- 4.InnoDB可重复读隔离级别下如何避免幻读?
- 5.RC,RR级别下InnoDB的非阻塞读如何实现?

### 1.1.MySIAM与InnoDB关于锁方面的区别是什么?
- 1.MySIAM默认用的是表级锁,不支持行级锁
- 2.InnoDB默认用的是行级锁,也支持表级锁

#### 1.1.1.什么时候适合使用MyISAM适合场景
- 1.频繁执行全表count语句
- 2.对数据进行增删改的频率不高,查询非常频繁
- 3.没有事务

#### 1.1.2.什么适合适合使用InnoDB
- 1.对增删改查都特别频繁的操作
- 2.可靠性要求比较高,需要支持事务

#### 1.1.3.数据库锁的分类
- 1.按锁的颗粒度划分: 可分为表级锁,行级锁,页级锁
- 2.按锁的级别划分: 可分为共享锁,排它锁
- 3.按加锁方式划分: 自动锁,显示锁
- 4.按操作划分: DML锁,DDL锁

### 1.2.数据库事务的四大特性是什么?
- 1.原子性(Atomic)
- 2.一致性(Consistency)
- 3.**隔离性(Isolation)**
- 4.持久性(Durability)


### 1.3.事务的隔离级别以及各级别下的并发访问问题
- 1.更新丢失------MySQL所有事务隔离级别上 均可避免
- 2.脏读---------READ-COMMITED事务隔离级别上可避免
- 3.不可重复读---REPEATABLE-READ事务隔离级别上可避免
- 4.幻读---------SERIALIZABLE事务隔离级别上可避免


#### 1.3.1.更新丢失
![fail](img/3.1.PNG)<br>
更新丢失在应用程序的层面可能发生。<br>

#### 1.3.2.脏读
A dirty read (aka uncommitted dependency) occurs when a transaction is allowed to read data from a row that has been modified by another running transaction and not yet committed.<br>
一个事务读到另一个事务未提交的数据。<br>

**READ-COMMITED**<br>
- 1.保证任何事务读取每次只能读取已提交的事务。<br>

#### 1.3.3.不可重复读
事务A多次读取数据(未做任何修改)结果不一致。<br>

**REPEATABLE-READ**<br>
- 1.事务A对数据做了修改，事务B对事务的修改修改操作会被锁住(读不会锁)。

#### 1.3.4.幻读
事务A在读取数据时，事务B在做插入删除操作。导致事务A读取到的数据比预想的数据行多或者少。<br>