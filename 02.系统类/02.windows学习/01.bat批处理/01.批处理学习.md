# 工作日志

## bat命令学习
[部分命令](https://blog.csdn.net/bingjie1217/article/details/12947327)<br>

[详细讲述](https://www.w3cschool.cn/dosmlxxsc1/wvqyr9.html)<br>

### 1.批处理中变量的使用
#### 1.1设置变量
```
set 变量名=变量值
```
被设置的变量以%变量名%引用<br>

#### 1.2取消变量
```
set 变量名=
```
取消后的变量若被引用%变量名%将为空

### 2.setlocal与Endlocal
开始批处理文件中环境改动的本地化操作。在执行 SETLOCAL 之后所做的环境改动只限于批处理文件。还原原先的设置，必须执行 ENDLOCAL。达到批处理文件结尾时，对于该批处理文件的每个尚未执行的 SETLOCAL 命令，都会有一个隐含的 ENDLOCAL 被执行。<br>

实例：<br>
```
@echo off
::fist echo
echo $(PATH)=%path%
setlocal
set path=E:/
::seconde echo
echo after change....$(PATH)=%path%
endlocal
::third echo
echo after change....$(PATH)=%path%
pause
```
执行结果如下：<br>
```
$(PATH)=D:\myTools\perl\site\bin;D:\myTools\perl\bin;C:\Program Files (x86)\Common Files\Oracle\Java\javapath;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\WINDOWS\System32\WindowsPowerShell\v1.0\;C:\WINDOWS\System32\OpenSSH\;D:\myTools\git\Git\cmd;D:\myTools\anaconda;D:\myTools\anaconda\Library\mingw-w64\bin;D:\myTools\anaconda\Library\usr\bin;D:\myTools\anaconda\Library\bin;D:\myTools\anaconda\Scripts;C:\Users\noble\AppData\Local\Microsoft\WindowsApps;D:\myTools\vsCode\Microsoft VS Code\bin;D:\myTools\notepade\Notepad++;
after change....$(PATH)=E:/
after change....$(PATH)=D:\myTools\perl\site\bin;D:\myTools\perl\bin;C:\Program Files (x86)\Common Files\Oracle\Java\javapath;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\WINDOWS\System32\WindowsPowerShell\v1.0\;C:\WINDOWS\System32\OpenSSH\;D:\myTools\git\Git\cmd;D:\myTools\anaconda;D:\myTools\anaconda\Library\mingw-w64\bin;D:\myTools\anaconda\Library\usr\bin;D:\myTools\anaconda\Library\bin;D:\myTools\anaconda\Scripts;C:\Users\noble\AppData\Local\Microsoft\WindowsApps;D:\myTools\vsCode\Microsoft VS Code\bin;D:\myTools\notepade\Notepad++;
```

从上例中我们可以看到，在setlocal和endlocal之间修改变量的不影响其他范围。<br>

#### 2.1 enabledelayedexpansion
我们将``enabledelayedexpansion``称为慢延迟。<br>
```
@echo off
set a=4
set a=5 & echo %a%
pause
```
结果：4<br>
解说：为什么是4而不是5呢？在echo之前明明已经把变量a的值改成5了？<br>
让我们先了解一下批处理运行命令的机制：<br>
批处理读取命令时是按行读取的（另外例如for命令等，其后用一对圆括号闭合的所有语句也当作一行），在处理之前要完成必要的预处理工作，这其中就包括对该行命令中的变量赋值。我们现在分析一下例1，批处理在运行到这句“set a=5 & echo %a%”之前，先把这一句整句读取并做了预处理——对变量a赋了值，那么%a%当然就是4了！（没有为什么，批处理就是这样做的。）<br>
而为了能够感知环境变量的动态变化，批处理设计了变量延迟。简单来说，在读取了一条完整的语句之后，不立即对该行的变量赋值，而会在某个单条语句执行之前再进行赋值，也就是说“延迟”了对变量的赋值。<br>
那么如何开启变量延迟呢？变量延迟又需要注意什么呢？举个例子说明一下：<br>
例2:<br>
```
@echo off
setlocal enabledelayedexpansion
set a=4
set a=5 & echo !a!
pause 
```
结果：5<br>
解说：启动了变量延迟，得到了正确答案。变量延迟的启动语句是“setlocal enabledelayedexpansion”，并且变量要用一对叹号“!!”括起来（注意要用英文的叹号），否则就没有变量延迟的效果。<br>
分析一下例2，首先“setlocal enabledelayedexpansion”开启变量延迟，然后“set a=4”先给变量a赋值为<br>
4，“set a=5 & echo !a!”这句是给变量a赋值为5并输出（由于启动了变量延迟，所以批处理能够感知到动态变化，即不是先给该行变量赋值，而是在运行过程中给变量赋值，因此此时a的值就是5了）。<br>