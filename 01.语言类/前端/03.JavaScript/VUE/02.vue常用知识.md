# vue项目尝试

## 1.引入vue框架
在该网站上查找连接:[https://www.bootcdn.cn/vue/](https://www.bootcdn.cn/vue/)<br>

## 2.模板语法
### 2.1.Vue文件结构

### 2.2.插值语法

### 2.3.指令(指令缩写) @click, v-if, :href

实例如下:<br>
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="https://cdn.bootcss.com/vue/2.5.17-beta.0/vue.min.js"></script>
</head>
<body>
<div id="app">
    <div v-bind:id="bg1">{{msg}}</div>

    <div>
        <a v-bind:href="url">牛客网</a>
        <a :href="url1">慕课网</a><!--v-bind缩写 -->
    </div>
    {{(count + 1)*10}}
    <!--缩写:<button type="button" @click="submit()">count++</button> -->
    <button type="button" v-on:click="submit()">count++</button>
    <div v-html="template"/><!--v-html后面的元素都被隐藏 -->
</div>
<script>
    new Vue({
        el: '#app',
        data: {
            bg1: 'app-bg1',
            msg: 'my vue!',
            count: 0,
            url: 'https://www.nowcoder.com/',
            url1: 'https://www.imooc.com/',
            template: '<div><strong>the template</strong><div/>'
        },
        methods:{
            submit: function () {
                this.count ++
            }
        }
    })
</script>
</body>
</html>
```

## 3.计算属性与监听属性

### 3.1.计算属性

### 实例:
```html
<div id="example">
  <p>Original message: "{{ message }}"</p>
  <p>Computed reversed message: "{{ reversedMessage }}"</p>
</div>
```

```js
var vm = new Vue({
  el: '#example',
  data: {
    message: 'Hello'
  },
  computed: {
    // 计算属性的 getter
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split('').reverse().join('')
    }
  }
})
```

### 结果:
```
Original message: "Hello"

Computed reversed message: "olleH"
```
可以像绑定普通属性一样在模板中绑定计算属性。``Vue`` 知道 ``vm.reversedMessage`` 依赖于 ``vm.message``，因此当 ``vm.message`` 发生改变时，所有依赖 ``vm.reversedMessage`` 的绑定也会更新。而且最妙的是我们已经以声明的方式创建了这种依赖关系：计算属性的 getter 函数是没有副作用 (side effect) 的，这使它更易于测试和理解。<br>


### 3.2.计算属性缓存 vs 方法
注意到我们可以通过在表达式中调用方法来达到同样的效果：<br>
```html
<p>Reversed message: "{{ reversedMessage() }}"</p>
```

```js
// 在组件中
methods: {
  reversedMessage: function () {
    return this.message.split('').reverse().join('')
  }
}
```
我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 ``message`` 还没有发生改变，多次访问 ``reversedMessage`` 计算属性会立即返回之前的计算结果，而不必再次执行函数。<br>
**特别注意:**<br>
下面的计算属性将不再更新，因为 Date.now() 不是响应式依赖:<br>
```js
computed: {
  now: function () {
    return Date.now()
  }
}
```

### 3.3.侦听属性
``Vue`` 提供了一种更通用的方式来观察和响应 ``Vue`` 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 ``watch``。然而，通常更好的做法是使用计算属性而不是命令式的 ``watch`` 回调。细想一下这个例子：<br>
```html
<div id="demo">{{ fullName }}</div>
```

```js
var vm = new Vue({
  el: '#demo',
  data: {
    firstName: 'Foo',
    lastName: 'Bar',
    fullName: 'Foo Bar'
  },
  watch: {
    //firstName 变化时会执行下面函数
    firstName: function (val) {
      this.fullName = val + ' ' + this.lastName
    },
    //lastName 变化时会执行下面函数
    lastName: function (val) {
      this.fullName = this.firstName + ' ' + val
    }
  }
})
```
上面代码是命令式且重复的。将它与计算属性的版本进行比较:<br>
```js
var vm = new Vue({
  el: '#demo',
  data: {
    firstName: 'Foo',
    lastName: 'Bar'
  },
  computed: {
    fullName: function () {
      return this.firstName + ' ' + this.lastName
    }
  }
})
```

