# 信号

## 1.信号的概念
信号是一种传达信息的载体，它有如下特点：<br>
- 1.简单
- 2.不能携带太多信息
- 3.在特定的时间发送

## 2.信号的机制
信号是内核发送给进程的。某个进程满足一定的条件时，驱使内核向某个进程发送一个信号。进程接受到信号后必须立即停止自己当前的代码执行，进程处理信号。<br>

## 3.信号的相关状态和事件
### 1.产生信号
- 1.按键产生，如：Ctrl+c、Ctrl+z、Ctrl+\
- 2.系统调用产生，如：kill、raise、abort
- 3.软件条件产生，如：定时器alarm
- 4.硬件异常产生，如：非法访问内存(段错误)、除0(浮点数例外)、内存对齐出错(总线错误)
- 5.命令产生，如：kill命令

### 2.信号的特质
信号是软件实现，对执行有很长的延时性(对CPU来说)，这会产生一些问题，如死锁等，而解决办法只能是通过更改程序逻辑来实现。<br>

### 3.信号的状态字
一般有两种表示信号的状态字，阻塞信号字和未响应信号字，当信号的阻塞字设为1时，产生的信号但在传递的过程中被阻塞。当产生的信号还未解决时未响应信号字设为1，任何信号都会有很短暂的置1时间，而阻塞信号会有较长时间的置1.<br>

### 4.信号类型
```
root@pro:~# kill -l
 1) SIGHUP        2) SIGINT         3) SIGQUIT        4) SIGILL         5) SIGTRAP
 6) SIGABRT       7) SIGBUS         8) SIGFPE         9) SIGKILL        10) SIGUSR1
11) SIGSEGV       12) SIGUSR2       13) SIGPIPE       14) SIGALRM       15) SIGTERM
16) SIGSTKFLT     17) SIGCHLD       18) SIGCONT       19) SIGSTOP       20) SIGTSTP
21) SIGTTIN       22) SIGTTOU       23) SIGURG        24) SIGXCPU       25) SIGXFSZ
26) SIGVTALRM     27) SIGPROF       28) SIGWINCH      29) SIGIO         30) SIGPWR
31) SIGSYS        34) SIGRTMIN      35) SIGRTMIN+1    36) SIGRTMIN+2    37) SIGRTMIN+3
38) SIGRTMIN+4    39) SIGRTMIN+5    40) SIGRTMIN+6    41) SIGRTMIN+7    42) SIGRTMIN+8
43) SIGRTMIN+9    44) SIGRTMIN+10   45) SIGRTMIN+11   46) SIGRTMIN+12   47) SIGRTMIN+13
48) SIGRTMIN+14   49) SIGRTMIN+15   50) SIGRTMAX-14   51) SIGRTMAX-13   52) SIGRTMAX-12
53) SIGRTMAX-11   54) SIGRTMAX-10   55) SIGRTMAX-9    56) SIGRTMAX-8    57) SIGRTMAX-7
58) SIGRTMAX-6    59) SIGRTMAX-5    60) SIGRTMAX-4    61) SIGRTMAX-3    62) SIGRTMAX-2
63) SIGRTMAX-1    64) SIGRTMAX
```

我们只关注前31个信号。<br>

### 5.信号的4要素
编号、名称、事件、默认处理动作 被称为信号的四要素。<br>
``man 7 signal``查看帮助文档获取<br>
```
Signal     Value     Action   Comment
──────────────────────────────────────────────────────────────────────
SIGHUP        1       Term    Hangup detected on controlling terminal
                              or death of controlling process
SIGINT        2       Term    Interrupt from keyboard
SIGQUIT       3       Core    Quit from keyboard
SIGILL        4       Core    Illegal Instruction
SIGABRT       6       Core    Abort signal from abort(3)
SIGFPE        8       Core    Floating-point exception
SIGKILL       9       Term    Kill signal
SIGSEGV      11       Core    Invalid memory reference
SIGPIPE      13       Term    Broken pipe: write to pipe with no
                              readers; see pipe(7)
SIGALRM      14       Term    Timer signal from alarm(2)
SIGTERM      15       Term    Termination signal
SIGUSR1   30,10,16    Term    User-defined signal 1
SIGUSR2   31,12,17    Term    User-defined signal 2
SIGCHLD   20,17,18    Ign     Child stopped or terminated
SIGCONT   19,18,25    Cont    Continue if stopped
SIGSTOP   17,19,23    Stop    Stop process
SIGTSTP   18,20,24    Stop    Stop typed at terminal
SIGTTIN   21,21,26    Stop    Terminal input for background process
SIGTTOU   22,22,27    Stop    Terminal output for background process
......
```

#### Value为什么有三个
在标准信号中，有一些信号是有三个“Value”，第一个值通常对alpha和sparc架构有效，中间值针对x86、arm和其他架构，最后一个应用于mips架构。一个‘-’表示在对应架构上尚未定义该信号。
不同的操作系统定义了不同的系统信号。因此有些信号出现在Unix系统内，也出现在Linux中，而有的信号出现在FreeBSD或Mac OS中却没有出现在Linux下。

#### 默认动作Action：
- Term：终止进程
- Ign： 忽略信号 (默认即时对该种信号忽略操作)
- Core：终止进程，生成Core文件。(查验进程死亡原因， 用于gdb调试)
- Stop：停止（暂停）进程
- Cont：继续运行进程

### 6.kill函数/命令产生信号
kill命令产生信号：kill -SIGKILL 进程ID<br>
kill函数：给指定进程发送指定信号(不一定杀死)<br>
``int kill(pid_t pid, int sig);``	 成功：0；失败：-1 (ID非法，信号非法，普通用户杀init进程等权级问题)，设置errno<br>

- sig：不推荐直接使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致。
- pid > 0:  发送信号给指定的进程。
- pid = 0:  发送信号给 与调用kill函数进程属于同一进程组的所有进程。
- pid < -1:  取|pid|发给对应进程组。
- pid = -1：发送给进程有权限发送的系统中所有进程。


进程组：每个进程都属于一个进程组，进程组是一个或多个进程集合，他们相互关联，共同完成一个实体任务，每个进程组都有一个进程组长，默认进程组ID与进程组长ID相同。<br>


### 7.alarm函数
设置定时器(闹钟)。在指定seconds后，内核会给当前进程发送14）SIGALARM信号。进程收到该信号，默认动作终止。<br>
每个进程都有且只有唯一的一个定时器。<br>
``unsigned int alarm(unsigned int seconds);`` 返回0或剩余的秒数，无失败。<br>
``alarm(0)``会取消之前设置的闹钟。<br>


### 8.信号屏蔽字的设定
为了实现对信号阻塞的设定，通过维护一个mask缓存，记录用户的缓冲设定，通过以下函数实现：<br>

- ``int sigemptyset(sigset_t *set);``			将某个信号集清0		 		成功：0；失败：-1，设置errno
- ``int sigfillset(sigset_t *set);``				将某个信号集置1		  		成功：0；失败：-1，设置errno
- ``int sigaddset(sigset_t *set, int signum);``		将某个信号加入信号集合中  	成功：0；失败：-1，设置errno
- ``int sigdelset(sigset_t *set, int signum);``		将某信号从信号清出信号集   	成功：0；失败：-1，设置errno
- ``int sigismember(const sigset_t *set, int signum);``判断某个信号是否在信号集中：在：1；不在：0；出错：-1，设置errno

 除sigismember外，其余操作函数中的set均为传出参数。sigset_t类型的本质是位图。但不应该直接使用位操作，而应该使用上述函数，确保代码的可移植性。<br>

### 9.sigprocmask函数
上面的函数只是更改缓存中的mask，如果要修改PCB中的信号字，就要使用sigprocmask函数。<br>
__严格注意__<br>
屏蔽信号：只是将信号处理延后执行(延至解除屏蔽)；而忽略表示将信号丢弃处理。<br>

``int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);``	成功：0；失败：-1，设置errno<br>

参数：
- set：传入参数，是一个自定义信号集合。由参数how来指示如何修改当前信号屏蔽字。
- oldset：传出参数，保存旧的信号屏蔽字。
- how参数取值：假设当前的信号屏蔽字为mask
  - 1.SIG_BLOCK: 当how设置为此值，set表示需要屏蔽的信号。相当于 mask = mask|set
  - 2.SIG_UNBLOCK: 当how设置为此，set表示需要解除屏蔽的信号。相当于 mask = mask & ~set
  - 3.SIG_SETMASK: 当how设置为此，set表示用于替代原始屏蔽及的新屏蔽集。相当于mask = set若，调用sigprocmask解除了对当前若干个信号的阻塞，则在sigprocmask返回前，至少将其中一个信号递达。

### 10.sigpending函数
读取当前进程的未处理信号字<br>
``int sigpending(sigset_t *set);``	set传出参数。   返回值：成功：0；失败：-1，设置errno<br>


### 11.实例
下面的程序是对上面程序的一般使用实例：<br>
```c
#include<stdio.h>
#include<unistd.h>
#include<signal.h>
void printset(const sigset_t *ped)
{
        int i;
        for(i=0;i<32;i++)
        {
                if((sigismember(ped,i)==1))
                        putchar('1');
                else
                        putchar('0');
        }
        printf("\n");
}
int main()
{
        sigset_t set,ped;
        sigemptyset(&set);
        sigaddset(&set,SIGINT);
        sigaddset(&set,SIGQUIT);

        sigprocmask(SIG_BLOCK,&set,NULL);
        while(1){
                sigpending(&ped);
                printset(&ped);
                sleep(1);
        }
        return 0;
}
```
