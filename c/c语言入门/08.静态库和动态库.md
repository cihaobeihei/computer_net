# 3.函数库
函数库的作用：代码复用<br>
自己可以通过函数库积累程序<br>
## 1.静态库
运行时会把静态库完整的加载到可执行程序<br>
比如：我的可执行程序是4k，但是用到一个a.h的3M静态库，那么编译完成后的程序大小就是3M+4K。<br>
- 优点：静态库有程序定义，编译后可以本地化所以函数，寻址速度快
- 缺点：占内存大
- 使用场景：多用于核心程序，保证程序的实效性。
- 制作：
  - 1.``gcc -c +源文件名``　　　　　　　　　　　　 -->编译得到*.o文件
  - 2.``ar rs lib_xxx_.a +上一步编译生成的.o文件``　 -->得到静态库
    - r更新、s建立索引
  - 3. ``gcc main.c -L ./ -l name -o main.o`` 　　-->使用静态库
- 使用：L：指定静态库所在目录；l：指定静态库的名字；I：指定头文件所在目录。

## 2.动态库
动态库又叫共享库，在程序运行时，动态库拷贝一份到内存。<br>
- 优点；节省空间，同时利于更新
- 缺点：程序运行时实际调用函数时才会调用，所以有些慢。<br>
- 使用场景：对速度要求不是很高的程序
- 制作：
  - ``gcc -fPIC -c +源文件``（-fPIC:将绝对地址变为相对地址，是指偏移量）
  - ``gcc -shared -o lib_xxx_.so +上一步形成的.o文件``
  - 3. ``gcc main.c -L ./ -l name -o main.o`` 　　-->使用动态库
- 运行 .main.o 出错
  原因是在查找自定义动态库时未找到，以下是解决方法
  - 环境变量法：配置环境变量``LD_LIBRARY_PATH``
  - 将自己的动态库放到 /lib/目录下---不要用这种方法，用户级的文件不要放到系统级别目录
  - 更改配置文件：将自己的lib.so文件路径加入到``/etc/ld.so.conf``文件中，使用``sudo ldconfig -v`` 动态更新``/etc/ld.so.cache``文件（2进制）ubuntu和centos6-7都有

### 动态库名称设置
这里涉及程序管理知识<br>
动态库是可能会更新的，那么会有一个版本号，但是用户在使用和或者程序要使用是不关心版本号的，所以动态库会有一个soname和linkname。<br>
创建动态库（加soname）：``gcc -shared -W1,-soname,lib_xxx_.so.1 -o lib_xxx_.so.1.1 +file.o文件``<br>
创建连接：``ln -s lib_xxx_.so.1.1 lib_xxx_.so``<br>

__注意：__ 当动态库和静态库重名都存在时，默认先找动态库。<br>

## 3.最好地策略
最好地策略是就使用动态库，不要使用静态库。<br>

## 4.函数库连接的5个秘密

#### 1.动态库文件的扩展名是".so"，静态库的文件扩展名是".a"。

#### 2.链接libthread.so文件库，在编译时加上``- lthread``
在链接时，我们没有告诉编译器函数库或文件的位置，仅仅加了一个``-lname``。实际上函数库的名字是``libname.so``，我们在编译时增加的参数省略了``lib``和扩展名``.so``，在``name``前面加了一个``l``<br>

#### 3.编译器期望在一些特定的位置找到函数库
我们没有给编译器任何路径的信息，那么编译器是在哪里找到函数库的呢？实际上是通过一些环境变量的值确定的。如``LD_LIBRARY_PATH``和``LD_RUN_PATH``，编译器会去某些目录查找函数库，比如``/usr/lib``目录中。<br>
我们在编译时，可以通过增加参数``-l``增加查找函数库的路径(在上述有实例说明如何使用)，也可以修改环境变量的值，但对于安全性和可扩展性的考虑，不建议使用后者。<br>

#### 4.编译时使用的连接参数
认清一个现实：我们在源文件中每个用``#include``包含的函数库都有可能需要在连接时加上特定的连接函数。如我们使用了``#include<thread.h>``头文件，就必须在编译时增加``-lthread``参数。<br>
下表是一般常见的函数库名和连接参数已经函数头的表格信息，你会发现函数头和源文件名不相同，这是C语言的一个混乱之处。<br>

|#include文件名|库文件名|需要用到编译选项|
|-------------|--------|---------------|
| <math.h>   | /usr/lib/libm.so  | -lm  |
| <math.h>   | /usr/lib/libm.a  | -dn -lm  |
| <stdio.h>   | /usr/lib/libc.so  | 自动连接  |
| "/usr/openwin/include/X11.h"  | /usr/openwin/lib/libX11.so  | -L/usr/openwin/lib -1Xll  |
| <thread.h>   | /usr/lib/libthread.so  | -lthread  |
| <curses.h>   | /usr/lib/libcurses.a  | -lcurses  |
| <sys/socket.h>   | /usr/lib/libsocket.so  | -lsocket  |


#### 5.静态库的连接符号要求比较严格
在静态库中先链接哪个静态库是有区别的，考虑如下事件：<br>
```
cc -lm main.c
cc main.c -lm
```
对于第一个命令，可能会出现问题是：<br>
```
Undefined   first referenced
symbol      in file
sin         main.o
......
```

这种问题可以使用动态库来避免。<br>

## 错误解决方案
### 错误一
在编译时出现关键字不可查找的错误：<br>
如下报错：<br>
```shell
ld: underfined symbol
  _xdr_reference
*** Error code 2
```

我们可以使用nm工具查找所有lib库，看看_xdr_reference的定义在什么地方。<br>
但要注意排除存在该关键字但被``UNDEF``修饰的文件，它的意思是声明不是定义。<br>
