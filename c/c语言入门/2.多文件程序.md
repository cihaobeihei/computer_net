# 多文件程序设计
## 1.理解 extern 和 static
要理解两个不同的概念： __申明__ 和 __定义__<br>
声明是指：该函数或变量在其他地方定义过了。<br>
定义是指：对于一个新变量或函数赋予意义，即命名，使我们可以使用它的左值和右值。<br>
__声明是不在内存开辟空间的 定义是要在内存开辟空间的__ C程序编译过程是将整个项目的所有文件链接起来编译，所以很有可能或者说一定会发生一种情况：一个变量或函数在一个源文件定义，但是编译过程中可能先编译了某个文件的内容使用了这个变量或函数，所以我们需要在这个文件中加上声明 告诉编译器我已经在其他地方声明过这个函数或变量了。<br>
extern只有一个意思：是申明。<br>
static有两个意思，根据上下文的不同而不同。<br>




## 3.头文件(XXX.h)和源文件(xxx.c)的编写规范
头文件用于声明模块 源文件实现和定义模块<br>
以下用config.c和config.h举例<br>
头文件模板：<br>
```C
#ifndef _CONFIG_H_  //保证每个函数头文件定义的值不同
#define _CONFIG_H_
.....//其他内容
#endif
```
源文件模板：<br>
```C
include "config.h"
......//其他内容
```
__以下是详细实例：__<br>
```C
//my_mem.h
#ifndef _CONFIG_H_
#define _CONFIG_H_
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<stdarg.h>
#define OUT
#define IN
extern int get_mem(IN int n_values, ...);
extern int free_mem(IN int n_values, ...);
#endif
```
```C
//my_mem.c
#include"my_mem.h"
int get_mem(IN int n_values, ...)
{
        if(n_values%2!=0)
        {
                fprintf(stderr,"error: number of values error!");
                return -1;
        }

        va_list var_arg;
        va_start(var_arg,n_values);

        for(;n_values>0;n_values-=2){
                char *p1=NULL;//pointer to memory space
                int len1=0;   //the lenth of space
                //read paraments that record size
                len1=va_arg(var_arg,int);
                //create memory spaces
                p1=(char*)malloc(len1);
                if(p1==NULL)
                {
                        fprintf(stderr,"error: malloc error!\n");
                        return -1;
                }
                memset(p1,0,len1);//memory create over
                *(va_arg(var_arg,char**))=p1;
                //from now the function create space successful
        }
        va_end(var_arg);
        return 0;
}
int free_mem(IN int n_values, ...)
{
        va_list var_arg;
        va_start(var_arg,n_values);

        for(;n_values>0;n_values--){
                char *p=NULL;//the point that will be free
                p=va_arg(var_arg,char*);//assign p variable
                if(p==NULL)
                {
                        fprintf(stderr,"error: pointer is NULL!\n");
                        return -1;
                }
                free(p);
        }

        va_end(var_arg);
        return 0;
}
```
## 3.函数库
函数库的作用：代码复用<br>
自己可以通过函数库积累程序<br>
### 1.静态库
运行时会把静态库完整的加载到可执行程序<br>
比如：我的可执行程序是4k，但是用到一个a.h的3M静态库，那么编译完成后的程序大小就是3M+4K。<br>
- 优点：静态库有程序定义，编译后可以本地化所以函数，寻址速度快
- 缺点：占内存大
- 使用场景：多用于核心程序，保证程序的实效性。
- 制作：
  - 1.``gcc -c +源文件名``　　　　　　　　　　　　 -->编译得到*.o文件
  - 2.``ar rs lib_xxx_.a +上一步编译生成的.o文件``　 -->得到静态库
    - r更新、s建立索引
  - 3. ``gcc main.c -L ./ -l name -o main.o`` 　　-->使用静态库
- 使用：L：指定静态库所在目录；l：指定静态库的名字；I：指定头文件所在目录。

### 2.动态库
动态库又叫共享库，在程序运行时，动态库拷贝一份到内存。<br>
- 优点；节省空间，同时利于更新
- 缺点：程序运行时实际调用函数时才会调用，所以有些慢。<br>
- 使用场景：对速度要求不是很高的程序
- 制作：
  - ``gcc -fPIC -c +源文件``（-fPIC:将绝对地址变为相对地址，是指偏移量）
  - ``gcc -shared -o lib_xxx_.so +上一步形成的.o文件``
  - 3. ``gcc main.c -L ./ -l name -o main.o`` 　　-->使用动态库
- 运行 .main.o 出错
  原因是在查找自定义动态库时未找到，以下是解决方法
  - 环境变量法：配置环境变量``LD_LIBRARY_PATH``
  - 将自己的动态库放到 /lib/目录下---不要用这种方法，用户级的文件不要放到系统级别目录
  - 更改配置文件：将自己的lib.so文件路径加入到``/etc/ld.so.conf``文件中，使用``sudo ldconfig -v`` 动态更新``/etc/ld.so.cache``文件（2进制）ubuntu和centos6-7都有

#### 动态库名称设置
这里涉及程序管理知识<br>
动态库是可能会更新的，那么会有一个版本号，但是用户在使用和或者程序要使用是不关心版本号的，所以动态库会有一个soname和linkname。<br>
创建动态库（加soname）：``gcc -shared -W1,-soname,lib_xxx_.so.1 -o lib_xxx_.so.1.1 +file.o文件``<br>
创建连接：``ln -s lib_xxx_.so.1.1 lib_xxx_.so``<br>

__注意：__ 当动态库和静态库重名都存在时，默认先找动态库。<br>

## 3.makefile的设计
写一组规则。<br>
### 里程碑一
创建makefile文件<br>
``touch manefile``<br>
### 里程碑二
