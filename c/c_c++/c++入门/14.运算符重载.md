# 运算符重载
## 1.概述
重载在C++语言中的意思是：赋予同一个对象更多的含义。<br>
我们知道函数重载，就是对一个同名的函数依据参数的不同赋予不同的意义。操作符的重载也是具有相同的意思。我们已经使用过一些重载的操作符。比如``+``运算符，我们可以使用``+``运算符进行正数浮点数的相加，但是我们知道计算机存储正数和浮点数的方式是不相同的，那么加法的运算原理也不相同。而C++已经帮我们做好了``+``的重载，所以我们可以理所当然的使用``+``进行加法运算。<br>

类似的在C++中的位运算符``>>``和``<<``在不同的场合也有不同的含义，除了用这些符号操作位之外，我们在使用``cout``时使用``<<``运算符实现对字符流的操作就是通过重载实现的，类似对``cin``使用时用到的``>>``运算符。 它们的重载定义就放在``stream``中，所以我们要使用这些运算符的重载功能就必须包含``stream``的头文件，当然还有``using namespace std;``。<br>

__注意：__<br>
运算符重载的本质是函数重载。<br>

## 2.语法格式
```cpp
函数类型 opertor运算符(形参){
  重载功能实现
}
```

比如：<br>

```cpp
const Complex operator+(const Complex &c1,const Complex &c2);
```

__实例：__<br>

全局的重载函数：<br>
```cpp
#include<iostream>
using namespace std;

class Complex
{
public:
  Complex(float x=0, float y=0):_x(x),_y(y){}

  void dis()
  {
    cout<<"("<<_x<<","<<_y<<")"<<endl;
  }
  friend const Complex operator+(const Complex &c1,const Complex &c2);
private:
  float _x;
  float _y;
};

const Complex operator+(const Complex &c1,const Complex &c2){
  return Complex(c1._x+c2._x,c1._y+c2._y);
}

int main(){
  Complex c1(2,3);
  Complex c2(3.4);
  c1.dis();
  c2.dis();

  Complex c3 = c1+c2;
  c3.dis();

  return 0;
}
```


将重载放在类内部：<br>
```cpp
#include<iostream>
using namespace std;
class Complex
{
public:
  Complex(float x=0,float y=0):_x(x),_y(y){}
  void dis(){
    cout<<"("<<","<<_y<<")"<<endl;
  }

  friend const Complex operator+(const Complex &c1,const Complex &c2);

  const Complex operator+(const Complex &another);
private:
  float _x;
  float _y;
};

const Complex operator+(const Comlex &c1,const Complex &c2)
{
  cout<<"There's a meta-function overload"<<endl;
  return Comlex(c1._x+c2._x,c1._y+c2._y);
}

const Complex Complex::operator+(const Complex & another)
{
  cout<<"Member function overload"<<endl;
  return Complex(this->_x+another._x,this->_y+another._y);
}

int main()
{
  Comlex c1(2,3);
  Comlex c2(3,4);

  c1.dis();
  c2.dis();

  Comlex c3 = c1+c2;
  c3.dis();

  return 0;
}
```

## 3.重载规则

### 1.只能重载C++现存在的运算符，不存在的运算符不能重载
比如在BASIC中用``**``表示幂运算符，如果想要在C++中也重载不存在的``**``运算符是不行的。<br>

### 2.C++运行重载的运算符

|  new |  new[] | delete  | delete[]  | +  | -  | *  |
|-----|-----|----|----|-----|----|----|
|  / |  % |  ^ | &  | l  | ~  |  ! |
| =  | <  |  > | +=  | -=  | *=  | /=  |
| %=  | ^=  | &=  | l=  | <<  | >>  | <<=  |
| >>=  | ==  | !=  | <=  | >=  | &&  | ll  |
| ++  | --  | ,  | ->*  | ->  | ()  | []  |


不可被重载的运算符有四个：<br>

| . | 成员选择符 |
|---|-----------|
| .*  | 成员对象选择符  |
| ::  | 域解析运算符  |
| ?:  | 条件操作符  |


### 3.重载不能改变运算方法运算对象(即操作数)的个数
如关系运算符``<<``和``>>``是双目运算符，重载后任然为双目运算符，需要两个参数。运算符``+``,``-``,``*``,``&``等运算符既可以做单目运算符，也可以做双目运算符，可以分别将他们重载为单目运算符或双目运算符。<br>

### 4.重载运算符的优先级别
例如``*``和``/``比``+``和``-``运算符优先级高，当重载之后的运算符，优先级不变，只有通过加括号的方式执行我们期望的运算顺序。<br>

### 5.重载不能改变运算符的结合性
例如：负载运算符``=``是由右至左的，重载之后运算符的运算方向不变

### 6.重载运算符不能有默认参数
否则就改变了运算符的个数，与前面第3点矛盾

### 7.重载运算符必须和用户定义的自定义类型的对象一起使用，其参数至少应该有一个是类对象(或类对象的引用)。

意思是说：参数不能全是C++标准类型，以防止用户修改用于标准类型数据成员的运算性质，如下面的重载定义是非法的：<br>

```cpp
int operator+(int a,int b){
  return (a-b);
}
```
原理运算符+的作用是对两个数相加，现在企图通过重载它的作用改为两个数相减。如果允许这样的重载，那么4+3到底等于1还是7呢？显然，这种操作时必须要禁止的。<br>

### 8.用于类运算符一般必须重载，但有两个例外，运算符``=``和``&``不必用户重载
赋值运算符本身可以用于同一种类创建的对象之间的赋值，已经由编译器实现。<br>
取地址运算符可以返回类对象在内存中的首地址。<br>

### 9.应当使重载运算符的功能类似于该运算符作用于标准类型数据时所实现的功能
例如：我们会重载``+``实现类对象内部私有成员的值相加，但不会重载``+``来做私有成员间的镶件操作。<br>

### 10.运算符重载函数可以是类的成员函数，也可以是类的友元函数，还可以是即非类的成员函数也不是友元函数的普通函数
